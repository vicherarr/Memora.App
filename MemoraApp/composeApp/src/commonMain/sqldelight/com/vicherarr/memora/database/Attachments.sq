-- Attachments table schema matching EXACTLY the backend API
-- API: ArchivoAdjunto.cs -> SQLDelight local storage + sync fields

CREATE TABLE attachments (
    id TEXT NOT NULL PRIMARY KEY,
    file_path TEXT NOT NULL,
    remote_url TEXT,
    nombre_original TEXT NOT NULL,
    tipo_archivo INTEGER NOT NULL, -- 1=Imagen, 2=Video (matching TipoDeArchivo enum)
    tipo_mime TEXT NOT NULL,
    tamano_bytes INTEGER NOT NULL,
    fecha_subida TEXT NOT NULL,
    nota_id TEXT NOT NULL,
    
    -- Enhanced sync management fields for attachment sync
    sync_status TEXT NOT NULL DEFAULT 'PENDING',        -- PENDING, UPLOADING, SYNCED, FAILED, DELETED
    needs_upload INTEGER NOT NULL DEFAULT 1,            -- 0=no, 1=yes
    local_created_at INTEGER NOT NULL,                  -- timestamp local creation
    last_sync_attempt INTEGER,                          -- last sync attempt timestamp
    
    -- New sync fields for attachment path transition
    remote_path TEXT,                                   -- structured path in Google Drive
    remote_file_id TEXT,                               -- Google Drive file ID
    content_hash TEXT,                                 -- SHA256 hash for integrity verification
    download_status TEXT DEFAULT 'NONE',              -- NONE, DOWNLOADING, DOWNLOADED, FAILED
    is_cached_locally INTEGER NOT NULL DEFAULT 1,     -- 0=not cached, 1=cached locally
    is_structured_path INTEGER NOT NULL DEFAULT 0,    -- 0=original path, 1=structured path
    
    FOREIGN KEY (nota_id) REFERENCES notes(id) ON DELETE CASCADE
);

-- Indexes for faster queries
CREATE INDEX attachments_nota_id_idx ON attachments(nota_id);
CREATE INDEX attachments_sync_status_idx ON attachments(sync_status);
CREATE INDEX attachments_needs_upload_idx ON attachments(needs_upload);
CREATE INDEX attachments_tipo_archivo_idx ON attachments(tipo_archivo);
-- New indexes for enhanced sync
CREATE INDEX attachments_remote_file_id_idx ON attachments(remote_file_id);
CREATE INDEX attachments_content_hash_idx ON attachments(content_hash);
CREATE INDEX attachments_download_status_idx ON attachments(download_status);
CREATE INDEX attachments_is_structured_path_idx ON attachments(is_structured_path);

-- Queries
getAllAttachments:
SELECT * FROM attachments ORDER BY fecha_subida DESC;

getAttachmentsByNoteId:
SELECT * FROM attachments 
WHERE nota_id = ? 
ORDER BY fecha_subida DESC;

getAttachmentById:
SELECT * FROM attachments WHERE id = ?;

getAttachmentsNeedingSync:
SELECT * FROM attachments 
WHERE sync_status = 'PENDING' OR sync_status = 'FAILED'
ORDER BY local_created_at ASC;

insertAttachment:
INSERT INTO attachments (
    id, file_path, nombre_original, tipo_archivo, tipo_mime,
    tamano_bytes, fecha_subida, nota_id, sync_status, needs_upload, local_created_at, remote_url,
    remote_path, remote_file_id, content_hash, download_status, is_cached_locally, is_structured_path
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);

updateAttachment:
UPDATE attachments 
SET file_path = ?, nombre_original = ?, tipo_archivo = ?, 
    tipo_mime = ?, tamano_bytes = ?, fecha_subida = ?,
    sync_status = 'PENDING', needs_upload = 1
WHERE id = ?;

updateSyncStatus:
UPDATE attachments 
SET sync_status = ?, needs_upload = ?, last_sync_attempt = ?
WHERE id = ?;

updateRemoteUrl:
UPDATE attachments
SET remote_url = ?
WHERE id = ?;

deleteAttachment:
DELETE FROM attachments WHERE id = ?;

deleteAttachmentsByNoteId:
DELETE FROM attachments WHERE nota_id = ?;

markAsSynced:
UPDATE attachments 
SET sync_status = 'SYNCED', needs_upload = 0, last_sync_attempt = ?
WHERE id = ?;

markSyncFailed:
UPDATE attachments 
SET sync_status = 'FAILED', last_sync_attempt = ?
WHERE id = ?;

-- Count attachments per note (useful for UI)
countAttachmentsByNoteId:
SELECT COUNT(*) FROM attachments WHERE nota_id = ?;

-- Get image attachments only
getImageAttachmentsByNoteId:
SELECT * FROM attachments 
WHERE nota_id = ? AND tipo_archivo = 1
ORDER BY fecha_subida DESC;

-- Get video attachments only
getVideoAttachmentsByNoteId:
SELECT * FROM attachments 
WHERE nota_id = ? AND tipo_archivo = 2
ORDER BY fecha_subida DESC;

-- Enhanced sync queries for attachment workflow
getAttachmentsNeedingUpload:
SELECT * FROM attachments 
WHERE sync_status IN ('PENDING', 'FAILED') AND needs_upload = 1
ORDER BY local_created_at ASC;

getAttachmentsNeedingDownload:
SELECT * FROM attachments 
WHERE download_status = 'NONE' OR download_status = 'FAILED'
ORDER BY local_created_at ASC;

getAttachmentsByContentHash:
SELECT * FROM attachments WHERE content_hash = ?;

getAttachmentsWithOriginalPaths:
SELECT * FROM attachments WHERE is_structured_path = 0;

getAttachmentsWithStructuredPaths:
SELECT * FROM attachments WHERE is_structured_path = 1;

-- Update queries for path transition workflow
updateToStructuredPath:
UPDATE attachments 
SET 
    file_path = ?,
    remote_file_id = ?,
    remote_path = ?,
    content_hash = ?,
    sync_status = 'SYNCED',
    needs_upload = 0,
    download_status = 'DOWNLOADED',
    is_cached_locally = 1,
    is_structured_path = 1,
    last_sync_attempt = ?
WHERE id = ?;

updateSyncMetadata:
UPDATE attachments 
SET 
    remote_file_id = ?,
    remote_path = ?,
    content_hash = ?,
    sync_status = ?,
    needs_upload = ?,
    last_sync_attempt = ?
WHERE id = ?;

updateDownloadStatus:
UPDATE attachments 
SET download_status = ?, last_sync_attempt = ?
WHERE id = ?;

updateCacheStatus:
UPDATE attachments 
SET is_cached_locally = ?
WHERE id = ?;